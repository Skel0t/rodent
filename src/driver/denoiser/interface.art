#[import(cc = "C")] fn mkl_blas_mm_mult(_m: i32, _n: i32, _k: i32, _a: &[f32], _lda: i32, _b: &[f32], _ldb: i32, _c: &mut[f32], _ldc: i32) -> ();
#[import(cc = "C")] fn mkl_add_constant(_n: i32, _a: &[f32], _val: f32, _res: &mut[f32]) -> ();
#[import(cc = "C")] fn mkl_add_elemwise(_n: i32, _a: &[f32], _b: &[f32], _c: &mut[f32]) -> ();
#[import(cc = "C")] fn mkl_apply_relu(_n: i32, _a: &[f32], _c: &mut[f32]) -> ();

#[export]
fn @get_necessary_mem(width: i32, height: i32) -> i64 {
    let size_im2col = (width as i64) * (height as i64) * (9 as i64) * (108 /*max in channels*/ as i64);  // size for im2col matrix
    let size_img    = (width as i64) * (height as i64) * (92 /*max out channels*/ as i64);                      // size to save matmul output
    let size_pool_3 = (width as i64) * (height as i64) * (32 as i64);    // sizes to save cross-connections
    let size_pool_2 = (width as i64) * (height as i64) * (16 as i64);
    let size_pool_1 = (width as i64) * (height as i64) * (12 as i64);

    4 * (size_im2col + size_img + size_pool_1 + size_pool_2 + size_pool_3)
}

#[export]
fn @forward_denoise(img_buf: &Buffer, alb_buf: &Buffer, nrm_buf: &Buffer, mem: &Buffer, width: i32, height: i32, out_buf: &Buffer, kernels: &Buffer, biases: &[f32]) -> () {
    let nn = make_denoise_nn(*kernels, biases, width, height);
    nn.forward(*img_buf, *alb_buf, *nrm_buf, *mem, *out_buf);
}
