/* Struct to return a forward propagation of a denoising neural network along
   with its memory consumption during computation. */
struct NN_DEN {
    forward : fn(Buffer, Buffer, Buffer, Buffer, Buffer) -> (),
    necess_mem : i64
}

/* Sets up a forward propagation of a sample denoising neural network provided
   and trained by Hendrik Junkawitsch as part of his bachelors thesis.
   The network's design is pretty much the same as OIDN, only small changes to
   the number of feature maps were made. */
fn @make_denoise_nn(kernels: Buffer, biases: &[f32], width: i32, height: i32) -> NN_DEN {
    /* Kernel size and poolsize is the same for every convolution / pooling layer */
    let ksize    = 3;
    let ksize_sq = ksize * ksize;
    let poolsize = 2;

    // ic -> ec1
    let in_channels_1  = 9;
    let out_channels_1 = 12;
    let offset_1 = 0 as i64;

    // ec1 -> ec1
    let in_channels_2  = out_channels_1;
    let out_channels_2 = 12;
    let offset_2 = offset_1 + (ksize_sq * in_channels_1 * out_channels_1) as i64;

    // ec1 -> ec2
    let in_channels_3  = out_channels_2;
    let out_channels_3 = 16;
    let offset_3 = offset_2 + (ksize_sq * in_channels_2 * out_channels_2) as i64;

    // ec2 -> ec3
    let in_channels_4  = out_channels_3;
    let out_channels_4 = 32;
    let offset_4 = offset_3 + (ksize_sq * in_channels_3 * out_channels_3) as i64;

    // ec3 -> ec4
    let in_channels_5  = out_channels_4;
    let out_channels_5 = 64;
    let offset_5 = offset_4 + (ksize_sq * in_channels_4 * out_channels_4) as i64;

    // ec4 -> ec5
    let in_channels_6  = out_channels_5;
    let out_channels_6 = 70;
    let offset_6 = offset_5 + (ksize_sq * in_channels_5 * out_channels_5) as i64;

    // ec5 -> ec5
    let in_channels_7  = out_channels_6;
    let out_channels_7 = 70;
    let offset_7 = offset_6 + (ksize_sq * in_channels_6 * out_channels_6) as i64;

    // ec5+ec3 -> dc4
    let in_channels_8  = out_channels_7 + out_channels_4;   // CROSS CONNECTION
    let out_channels_8 = 92;
    let offset_8 = offset_7 + (ksize_sq * in_channels_7 * out_channels_7) as i64;

    // dc4 -> dc4
    let in_channels_9  = out_channels_8;
    let out_channels_9 = 92;
    let offset_9= offset_8 + (ksize_sq * in_channels_8 * out_channels_8) as i64;

    // dc4+ec2 -> dc3
    let in_channels_10  = out_channels_9 + out_channels_3;  // CROSS CONNECTION
    let out_channels_10 = 70;
    let offset_10 = offset_9 + (ksize_sq * in_channels_9 * out_channels_9) as i64;

    // dc3 -> dc3
    let in_channels_11  = out_channels_10;
    let out_channels_11 = 70;
    let offset_11 = offset_10 + (ksize_sq * in_channels_10 * out_channels_10) as i64;

    // dc3+ec1 -> dc2
    let in_channels_12  = out_channels_11 + out_channels_2; // CROSS CONNECTION
    let out_channels_12 = 64;
    let offset_12 = offset_11 + (ksize_sq * in_channels_11 * out_channels_11) as i64;

    // dc2 -> dc2
    let in_channels_13  = out_channels_12;
    let out_channels_13 = 64;
    let offset_13 = offset_12 + (ksize_sq * in_channels_12 * out_channels_12) as i64;

    // dc2+ic -> dc1a
    let in_channels_14  = out_channels_13 + in_channels_1;  // CROSS CONNECTION
    let out_channels_14 = 32;
    let offset_14 = offset_13 + (ksize_sq * in_channels_13 * out_channels_13) as i64;

    // dc1a -> dc1b
    let in_channels_15  = out_channels_14;
    let out_channels_15 = 16;
    let offset_15 = offset_14 + (ksize_sq * in_channels_14 * out_channels_14) as i64;

    // dc1b -> oc
    let in_channels_16  = out_channels_15;
    let out_channels_16 = 3;
    let offset_16 = offset_15 + (ksize_sq * in_channels_15 * out_channels_15) as i64;

    /* Kernel matrices higher-order function to pass to the convolutions. */
    let flattened_kernels = @|i: i32| {
        match i {
            1  => make_matrix(kernels, offset_1,  MemoryFormat::CHW, 1, out_channels_1,  ksize_sq * in_channels_1),
            2  => make_matrix(kernels, offset_2,  MemoryFormat::CHW, 1, out_channels_2,  ksize_sq * in_channels_2),
            3  => make_matrix(kernels, offset_3,  MemoryFormat::CHW, 1, out_channels_3,  ksize_sq * in_channels_3),
            4  => make_matrix(kernels, offset_4,  MemoryFormat::CHW, 1, out_channels_4,  ksize_sq * in_channels_4),
            5  => make_matrix(kernels, offset_5,  MemoryFormat::CHW, 1, out_channels_5,  ksize_sq * in_channels_5),
            6  => make_matrix(kernels, offset_6,  MemoryFormat::CHW, 1, out_channels_6,  ksize_sq * in_channels_6),
            7  => make_matrix(kernels, offset_7,  MemoryFormat::CHW, 1, out_channels_7,  ksize_sq * in_channels_7),
            8  => make_matrix(kernels, offset_8,  MemoryFormat::CHW, 1, out_channels_8,  ksize_sq * in_channels_8),
            9  => make_matrix(kernels, offset_9,  MemoryFormat::CHW, 1, out_channels_9,  ksize_sq * in_channels_9),
            10 => make_matrix(kernels, offset_10, MemoryFormat::CHW, 1, out_channels_10, ksize_sq * in_channels_10),
            11 => make_matrix(kernels, offset_11, MemoryFormat::CHW, 1, out_channels_11, ksize_sq * in_channels_11),
            12 => make_matrix(kernels, offset_12, MemoryFormat::CHW, 1, out_channels_12, ksize_sq * in_channels_12),
            13 => make_matrix(kernels, offset_13, MemoryFormat::CHW, 1, out_channels_13, ksize_sq * in_channels_13),
            14 => make_matrix(kernels, offset_14, MemoryFormat::CHW, 1, out_channels_14, ksize_sq * in_channels_14),
            15 => make_matrix(kernels, offset_15, MemoryFormat::CHW, 1, out_channels_15, ksize_sq * in_channels_15),
            16 => make_matrix(kernels, offset_16, MemoryFormat::CHW, 1, out_channels_16, ksize_sq * in_channels_16),
            _  => make_matrix(kernels, offset_1,  MemoryFormat::CHW, 1, out_channels_1,  ksize_sq * in_channels_1)
        }
    };

    /* Biases higher-order function to pass to the convolutions. All offsets precalculated. */
    let biases = @|j: i32| {
        match j {
            1  => @|i: i32| { biases(i) },
            2  => @|i: i32| { biases(i + out_channels_1) },
            3  => @|i: i32| { biases(i + out_channels_1 + out_channels_2) },
            4  => @|i: i32| { biases(i + out_channels_1 + out_channels_2 + out_channels_3) },
            5  => @|i: i32| { biases(i + out_channels_1 + out_channels_2 + out_channels_3 + out_channels_4) },
            6  => @|i: i32| { biases(i + out_channels_1 + out_channels_2 + out_channels_3 + out_channels_4 + out_channels_5) },
            7  => @|i: i32| { biases(i + out_channels_1 + out_channels_2 + out_channels_3 + out_channels_4 + out_channels_5 + out_channels_6) },
            8  => @|i: i32| { biases(i + out_channels_1 + out_channels_2 + out_channels_3 + out_channels_4 + out_channels_5 + out_channels_6 + out_channels_7) },
            9  => @|i: i32| { biases(i + out_channels_1 + out_channels_2 + out_channels_3 + out_channels_4 + out_channels_5 + out_channels_6 + out_channels_7 + out_channels_8) },
            10 => @|i: i32| { biases(i + out_channels_1 + out_channels_2 + out_channels_3 + out_channels_4 + out_channels_5 + out_channels_6 + out_channels_7 + out_channels_8 + out_channels_9) },
            11 => @|i: i32| { biases(i + out_channels_1 + out_channels_2 + out_channels_3 + out_channels_4 + out_channels_5 + out_channels_6 + out_channels_7 + out_channels_8 + out_channels_9 + out_channels_10) },
            12 => @|i: i32| { biases(i + out_channels_1 + out_channels_2 + out_channels_3 + out_channels_4 + out_channels_5 + out_channels_6 + out_channels_7 + out_channels_8 + out_channels_9 + out_channels_10 + out_channels_11) },
            13 => @|i: i32| { biases(i + out_channels_1 + out_channels_2 + out_channels_3 + out_channels_4 + out_channels_5 + out_channels_6 + out_channels_7 + out_channels_8 + out_channels_9 + out_channels_10 + out_channels_11 + out_channels_12) },
            14 => @|i: i32| { biases(i + out_channels_1 + out_channels_2 + out_channels_3 + out_channels_4 + out_channels_5 + out_channels_6 + out_channels_7 + out_channels_8 + out_channels_9 + out_channels_10 + out_channels_11 + out_channels_12 + out_channels_13) },
            15 => @|i: i32| { biases(i + out_channels_1 + out_channels_2 + out_channels_3 + out_channels_4 + out_channels_5 + out_channels_6 + out_channels_7 + out_channels_8 + out_channels_9 + out_channels_10 + out_channels_11 + out_channels_12 + out_channels_13 + out_channels_14) },
            16 => @|i: i32| { biases(i + out_channels_1 + out_channels_2 + out_channels_3 + out_channels_4 + out_channels_5 + out_channels_6 + out_channels_7 + out_channels_8 + out_channels_9 + out_channels_10 + out_channels_11 + out_channels_12 + out_channels_13 + out_channels_14 + out_channels_15) },
            _  => @|_i:i32| { 0 as f32 } /* No bias */
        }
    };

    /* Calculate necessary memory */
    let size_im2col = (width as i64) * (height as i64) * (ksize_sq as i64) * (108 /*max in channels*/ as i64);  /* max size for im2col matrix */
    let size_img    = (width as i64) * (height as i64) * (92 /*max out channels*/ as i64);                      /* max size to save matmul output */
    /* Sizes to save cross-connections: */
    let size_pool_3 = (width as i64) * (height as i64) * (out_channels_4 as i64);
    let size_pool_2 = (width as i64) * (height as i64) * (out_channels_3 as i64);
    let size_pool_1 = (width as i64) * (height as i64) * (out_channels_2 as i64);

    /* Alltogether, multiplied by 4, since we are using 32bit floats. */
    let necess_mem = 4 * (size_im2col + size_img + size_pool_1 + size_pool_2 + size_pool_3);

    fn @forward_denoise(img: Buffer, albedo: Buffer, normal: Buffer, mem: Buffer, out_buf: Buffer) -> () {

        if cpu_profiling_enabled {
            total_counter   = 0;
            im2col_counter  = 0;
            matmul_counter  = 0;
            pool_counter    = 0;
            nearest_counter = 0;
        }

        cpu_profile(&mut total_counter, || {
            let mut img_mat = make_matrix(img, 0, MemoryFormat::HWC, 3, height, width);
            let alb_mat  = make_matrix(albedo, 0, MemoryFormat::HWC, 3, height, width);
            let nrm_mat  = make_matrix(normal, 0, MemoryFormat::HWC, 3, height, width);

            let img_acc = get_mat_acc(img_mat);
            let alb_acc = get_mat_acc(alb_mat);
            let nrm_acc = get_mat_acc(nrm_mat);

            let cat_acc = get_cat_mat_acc(get_cat_mat_acc(img_acc, alb_acc, img_mat.channels), nrm_acc, img_mat.channels + alb_mat.channels);

            // Convolution 1
            img_mat = cat_conv2d(ksize, out_channels_1, in_channels_1, flattened_kernels(1), biases(1), leaky_relu_x, img_mat.rows, img_mat.cols, cat_acc, mem, 0, size_im2col);

            // Convolution 2
            img_mat = conv2d(ksize, out_channels_2, flattened_kernels(2), biases(2), leaky_relu_x, img_mat, mem, 0, size_im2col);
            img_mat = pool(img_mat, poolsize, max_4, mem, size_im2col + size_img);    // POOL 1

            let pool_1 = get_mat_acc(img_mat);

            // Convolution 3
            img_mat = conv2d(ksize, out_channels_3, flattened_kernels(3), biases(3), leaky_relu_x, img_mat, mem, 0, size_im2col);
            img_mat = pool(img_mat, poolsize, max_4, mem, size_im2col + size_img + size_pool_1);    // POOL 2

            let pool_2 = get_mat_acc(img_mat);

            // Convolution 4
            img_mat = conv2d(ksize, out_channels_4, flattened_kernels(4), biases(4), leaky_relu_x, img_mat, mem, 0, size_im2col);
            img_mat = pool(img_mat, poolsize, max_4, mem, size_im2col + size_img + size_pool_1 + size_pool_2);    // POOL 3

            let pool_3 = get_mat_acc(img_mat);

            // Convolution 5
            img_mat = conv2d(ksize, out_channels_5, flattened_kernels(5), biases(5), leaky_relu_x, img_mat, mem, 0, size_im2col);
            img_mat = pool(img_mat, poolsize, max_4, mem, size_im2col);

            // Convolution 6
            img_mat = conv2d(ksize, out_channels_6, flattened_kernels(6), biases(6), leaky_relu_x, img_mat, mem, 0, size_im2col);

            // Convolution 7
            img_mat = conv2d(ksize, out_channels_7, flattened_kernels(7), biases(7), leaky_relu_x, img_mat, mem, 0, size_im2col);

            // Convolution 8
            let mat_acc_1 = nearest_acc(img_mat);             // This swaps mem locations of img_mat and im2col_mat
            let cat_acc_1 = get_cat_mat_acc(mat_acc_1, pool_3, img_mat.channels);
            img_mat = cat_conv2d(ksize, out_channels_8, in_channels_8, flattened_kernels(8), biases(8), leaky_relu_x, 2 * img_mat.rows, 2 * img_mat.cols, cat_acc_1, mem, 0, size_im2col);

            // Convolution 9
            img_mat = conv2d(ksize, out_channels_9, flattened_kernels(9), biases(9), leaky_relu_x, img_mat, mem, 0, size_im2col);

            // Convolution 10
            let mat_acc_2 = nearest_acc(img_mat);   // This swaps mem locations of img_mat and im2col_mat
            let cat_acc_2 = get_cat_mat_acc(mat_acc_2, pool_2, img_mat.channels);
            img_mat = cat_conv2d(ksize, out_channels_10, in_channels_10, flattened_kernels(10), biases(10), leaky_relu_x, 2 * img_mat.rows, 2 * img_mat.cols, cat_acc_2, mem, 0, size_im2col);

            // Convolution 11
            img_mat = conv2d(ksize, out_channels_11, flattened_kernels(11), biases(11), leaky_relu_x, img_mat, mem, 0, size_im2col);

            // Convolution 12
            let mat_acc_3 = nearest_acc(img_mat);   // This swaps mem locations of img_mat and im2col_mat
            let cat_acc_3 = get_cat_mat_acc(mat_acc_3, pool_1, img_mat.channels);
            img_mat = cat_conv2d(ksize, out_channels_12, in_channels_12, flattened_kernels(12), biases(12), leaky_relu_x, 2 * img_mat.rows, 2 * img_mat.cols, cat_acc_3, mem, 0, size_im2col);

            // Convolution 13
            img_mat = conv2d(ksize, out_channels_13, flattened_kernels(13), biases(13), leaky_relu_x, img_mat, mem, 0, size_im2col);

            // Convolution 14
            let mat_acc_4 = nearest_acc(img_mat);   // This swaps mem locations of img_mat and im2col_mat
            let cat_acc_4 = get_cat_mat_acc(mat_acc_4, cat_acc, img_mat.channels);
            img_mat = cat_conv2d(ksize, out_channels_14, in_channels_14, flattened_kernels(14), biases(14), leaky_relu_x, 2 * img_mat.rows, 2 * img_mat.cols, cat_acc_4, mem, 0, size_im2col);

            // Convolution 15
            img_mat = conv2d(ksize, out_channels_15, flattened_kernels(15), biases(15), leaky_relu_x, img_mat, mem, 0, size_im2col);

            // Convolution 16
            img_mat = conv2d(ksize, out_channels_16, flattened_kernels(16), biases(16), id, img_mat, mem, 0, size_im2col);

            // Write result in output buffer (necessary since rodent expects hwc while conv2d returns chw format)
            chw_to_hwc(img_mat, out_buf, 0);
        });

        if cpu_profiling_enabled {
            fn @print_counter(counter: i64, name: &[u8]) -> () {
                print_string(name);
                print_string(": ");
                print_i64(counter);
                print_string(" (");
                print_i64(counter * 100 / total_counter);
                print_string("%)\n");
            }
            let other_counter = total_counter - im2col_counter - matmul_counter;
            print_counter(im2col_counter, "im2col");
            print_counter(matmul_counter, "matmul");
            print_counter(pool_counter,   "pool");
            print_counter(nearest_counter,"nearest");
            print_counter(other_counter,  "other (than im2col and matmul)");
            print_string("\n");
        }
    }

    NN_DEN { forward = forward_denoise, necess_mem = necess_mem }
}
