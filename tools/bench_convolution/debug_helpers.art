fn @get_debug_nn() -> NNInt {
    NNInt {
        matmul     = matmul_cpu,
        im2col     = im2col_cpu,
        pool       = pool_cpu_on_gpu,
        nearest    = nearest,
        chw_to_hwc = chw_to_hwc_cpu
    }
}

fn @pool_cpu_on_gpu(img_mat: Matrix, size: i32, pooling_fn: fn(fn(i32) -> f32) -> f32, buf: Buffer, off: i64) -> Matrix {
    let res_mat = make_matrix(buf, off, img_mat.format, img_mat.channels, img_mat.rows / size, img_mat.cols / size);

    let d_a = runtime_alloc(runtime_device(1, 0), 4 * img_mat.rows as i64 * img_mat.cols as i64 * img_mat.channels as i64);
    let d_b = runtime_alloc(runtime_device(1, 0),     img_mat.rows as i64 * img_mat.cols as i64 * img_mat.channels as i64);

    copy_host_to_dev(bitcast[&[i8]](&(img_mat.buf.data(4 * img_mat.offset))), d_a, 0, 4 * img_mat.rows as i64 * img_mat.cols as i64 * img_mat.channels as i64);

    let a_buf = Buffer {
        data = d_a,
        size = 4 * img_mat.rows as i64 * img_mat.cols as i64 * img_mat.channels as i64,
        device = 0x01
    };
    let b_buf = Buffer {
        data = d_b,
        size =     img_mat.rows as i64 * img_mat.cols as i64 * img_mat.channels as i64,
        device = 0x01
    };

    let a_mat = make_matrix(a_buf, 0, img_mat.format, img_mat.channels, img_mat.rows, img_mat.cols);

    pool_gpu(a_mat, size, pooling_fn, b_buf, 0);

    copy_dev_to_host(bitcast[&mut[i8]](&(res_mat.buf.data(4 * res_mat.offset))), d_b, 0, img_mat.rows as i64 * img_mat.cols as i64 * img_mat.channels as i64);

    runtime_release(runtime_device(1, 0), d_a);
    runtime_release(runtime_device(1, 0), d_b);

    res_mat
}

fn @copy_host_to_dev(host_memory: &[i8], device_memory: &mut [i8], dev: i32, size: i64) -> () {
    runtime_copy(runtime_device(0, 0), host_memory, 0, runtime_device(1, dev), device_memory, 0, size);
}

fn @copy_dev_to_host(host_memory: &mut [i8], device_memory: &[i8], dev: i32, size: i64) -> () {
    runtime_copy(runtime_device(1, dev), device_memory, 0, runtime_device(0, 0), host_memory, 0, size);
}
